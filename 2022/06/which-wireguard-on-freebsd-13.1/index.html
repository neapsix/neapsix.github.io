<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=favicon.ico><link rel=stylesheet href=/css/style.min.css><title>Which WireGuard on FreeBSD 13.1?</title></head><body><header id=banner><h2><a href>neap space</a></h2><nav><ul><li><a href=/ title=posts>posts</a></li><li><a href=/about/ title=about>about</a></li></ul></nav></header><main id=content><article><header id=post-header><h1>Which WireGuard on FreeBSD 13.1?</h1><time>June 4, 2022</time></header><p>I&rsquo;m enjoying using FreeBSD 13.1 on my old ThinkPad X230.
One thing I haven&rsquo;t tried yet is using WireGuard for VPN connections on FreeBSD.
There are two WireGuard ports: <code>wireguard-kmod</code>, the experimental in-kernel version, and <code>wireguard-go</code>, the stable, cross-platform implementation.
I tried both to see which I should use.</p><h3 id=setting-up-experimental-in-kernel-wireguard>Setting Up Experimental In-Kernel Wireguard</h3><p>Let&rsquo;s start with the fun version.
This port is the in-kernel version from zx2c4, written by Jason Donenfeld and Kyle Evans&ndash;not to be confused with the infamous Netgate-sponsored port that was yanked from FreeBSD 13.
It&rsquo;s still under development and comes with disclaimers about using it in production.</p><p>To use it, install the package and the userland tools to control it.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span># pkg install wireguard-kmod wireguard-tools
</span></span></code></pre></div><p>The package notes (use <code>pkg info -D wireguard-kmod</code> to see them again) show a warning that the code is unvetted and might contain security issues.
They don&rsquo;t include information about how to use the kernel module.</p><p>I assumed I would have to load it by name with <code>kldload</code>.
To find the name, I listed all the files installed by the package.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>$ pkg info -l wireguard-kmod
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#44475a>wireguard-kmod-0.0.20211105_1:
</span></span></span><span style=display:flex><span><span style=color:#44475a>	/boot/modules/if_wg.ko
</span></span></span><span style=display:flex><span><span style=color:#44475a>	/usr/local/share/licenses/wireguard-kmod-0.0.20211105_1/LICENSE
</span></span></span><span style=display:flex><span><span style=color:#44475a>	/usr/local/share/licenses/wireguard-kmod-0.0.20211105_1/MIT
</span></span></span><span style=display:flex><span><span style=color:#44475a>	/usr/local/share/licenses/wireguard-kmod-0.0.20211105_1/catalog.mk
</span></span></span></code></pre></div><p>However, I got an error when I loaded it by name.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span># kldload if_wg
</span></span><span style=display:flex><span><span style=color:#44475a>kldload: can&#39;t load if_wg: module already loaded or in kernel
</span></span></span></code></pre></div><p>Checking whether the module is loaded gives us exit code 0 (success).
I guess it&rsquo;s loaded by default!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span># kldstat -q -n if_wg; <span style=color:#8be9fd;font-style:italic>echo</span> <span style=color:#8be9fd;font-style:italic>$?</span>
</span></span><span style=display:flex><span><span style=color:#44475a>0
</span></span></span></code></pre></div><p>Configuring, starting, and stopping tunnels works the same as on other platforms with <code>wireguard-tools</code>.
I defined the <code>wg0</code> tunnel by creating <code>/usr/local/etc/wireguard/wg0.conf</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml><span style=display:flex><span><span style=color:#6272a4>#</span>
</span></span><span style=display:flex><span><span style=color:#6272a4># wg0.conf - wireguard configuration for a client machine (e.g. a laptop)</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>#</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[Interface]
</span></span><span style=display:flex><span>Address = <span style=color:#6272a4># 10.2.0.&lt;Your Address Here&gt;/24</span>
</span></span><span style=display:flex><span>PrivateKey = <span style=color:#6272a4># &lt;Your Private Key Here&gt;</span>
</span></span><span style=display:flex><span>DNS = <span style=color:#bd93f9>1.1</span>.<span style=color:#bd93f9>1.1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># Gateway server</span>
</span></span><span style=display:flex><span>[Peer]
</span></span><span style=display:flex><span>Endpoint = url.of.gateway:<span style=color:#bd93f9>51820</span>
</span></span><span style=display:flex><span>PublicKey = <span style=color:#6272a4># &lt;Gateway Server&#39;s Public Key Here&gt;</span>
</span></span><span style=display:flex><span>AllowedIPs = <span style=color:#bd93f9>10.2</span>.<span style=color:#bd93f9>0.0</span>/<span style=color:#bd93f9>24</span>,<span style=color:#bd93f9>192.168</span>.<span style=color:#bd93f9>1.0</span>/<span style=color:#bd93f9>24</span>
</span></span><span style=display:flex><span>PersistentKeepAlive = <span style=color:#bd93f9>25</span>
</span></span></code></pre></div><p>Starting the tunnel revealed another difference between FreeBSD and Linux.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span># wg-quick up wg0           
</span></span><span style=display:flex><span><span style=color:#44475a>[#] ifconfig wg create name wg0
</span></span></span><span style=display:flex><span><span style=color:#44475a>[#] wg setconf wg0 /dev/stdin
</span></span></span><span style=display:flex><span><span style=color:#44475a>[#] ifconfig wg0 inet 10.2.0.10/24 alias
</span></span></span><span style=display:flex><span><span style=color:#44475a>[#] ifconfig wg0 mtu 1420
</span></span></span><span style=display:flex><span><span style=color:#44475a>[#] ifconfig wg0 up
</span></span></span><span style=display:flex><span><span style=color:#44475a>[#] resolvconf -a wg0 -x
</span></span></span><span style=display:flex><span><span style=color:#44475a>[#] route -q -n add -inet 192.168.1.0/24 -interface wg0
</span></span></span><span style=display:flex><span><span style=color:#44475a>[#] resolvconf -d wg0
</span></span></span><span style=display:flex><span><span style=color:#44475a>[#] ifconfig wg0 destroy
</span></span></span></code></pre></div><p>Uh oh, <code>ifconfig</code> destroyed my wg0 interface immediately after creating it!
Apparently, FreeBSD won&rsquo;t let me add a route that conflicts with an already active interface.
Linux lets you create the link.</p><p>To set up a route for 192.168.1.0/24 (my home network subnet), I have to make sure I don&rsquo;t already have one.
For now, I only need to get to the 10.2.0.10/24 subnet, so I removed the other one from the AllowedIPs parameter.</p><h4 id=usrlocaletcwireguardwg0conf><code>/usr/local/etc/wireguard/wg0.conf</code></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml><span style=display:flex><span>AllowedIPs = <span style=color:#bd93f9>10.2</span>.<span style=color:#bd93f9>0.0</span>/<span style=color:#bd93f9>24</span>
</span></span></code></pre></div><p>That changed fixed the issue.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span># wg-quick up wg0
</span></span><span style=display:flex><span><span style=color:#44475a>[#] ifconfig wg create name wg0
</span></span></span><span style=display:flex><span><span style=color:#44475a>[#] wg setconf wg0 /dev/stdin
</span></span></span><span style=display:flex><span><span style=color:#44475a>[#] ifconfig wg0 inet 10.2.0.10/24 alias
</span></span></span><span style=display:flex><span><span style=color:#44475a>[#] ifconfig wg0 mtu 1420
</span></span></span><span style=display:flex><span><span style=color:#44475a>[#] ifconfig wg0 up
</span></span></span><span style=display:flex><span><span style=color:#44475a>[#] resolvconf -a wg0 -x
</span></span></span><span style=display:flex><span><span style=color:#44475a>[+] Backgrounding route monitor
</span></span></span><span style=display:flex><span><span style=color:#44475a></span>
</span></span><span style=display:flex><span># wg show
</span></span><span style=display:flex><span><span style=color:#44475a>interface: wg0
</span></span></span><span style=display:flex><span><span style=color:#44475a>  public key: &lt;My client&#39;s public key&gt;
</span></span></span><span style=display:flex><span><span style=color:#44475a>  private key: (hidden)
</span></span></span><span style=display:flex><span><span style=color:#44475a>  listening port: 40839
</span></span></span><span style=display:flex><span><span style=color:#44475a></span>
</span></span><span style=display:flex><span><span style=color:#44475a>peer: &lt;My gateway server&#39;s public key&gt;
</span></span></span><span style=display:flex><span><span style=color:#44475a>  endpoint: &lt;IP Address&gt;:51820
</span></span></span><span style=display:flex><span><span style=color:#44475a>  allowed ips: 10.2.0.0/24
</span></span></span><span style=display:flex><span><span style=color:#44475a>  latest handshake: 30 seconds ago
</span></span></span><span style=display:flex><span><span style=color:#44475a>  transfer: 92 B received, 212 B sent
</span></span></span><span style=display:flex><span><span style=color:#44475a>  persistent keepalive: every 25 seconds
</span></span></span></code></pre></div><p>The last thing to do is to enable the tunnel on startup.
I suspected that wireguard-tools came with an <code>rc</code> script to do so.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>$ pkg info -l wireguard-tools
</span></span><span style=display:flex><span><span style=color:#44475a>wireguard-tools-1.0.20210914_1:
</span></span></span><span style=display:flex><span><span style=color:#44475a>	/usr/local/bin/wg
</span></span></span><span style=display:flex><span><span style=color:#44475a>	/usr/local/bin/wg-quick
</span></span></span><span style=display:flex><span><span style=color:#44475a>	/usr/local/etc/rc.d/wireguard
</span></span></span><span style=display:flex><span><span style=color:#44475a>[...]
</span></span></span></code></pre></div><p>Yep, there it is. The comment at the top of <code>/usr/local/etc/rc.c/wireguard</code> explains how to configure it in <code>/etc/rc.conf</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>wireguard_enable</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;YES&#34;</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>wireguard_interfaces</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;wg0&#34;</span>
</span></span></code></pre></div><p>With those lines, the tunnel can be started using <code>service wireguard start</code>.</p><h3 id=setting-up-stable-userland-wireguard>Setting Up Stable Userland WireGuard</h3><p>All we have to do to try out <code>wireguard-go</code> is to swap out the package that&rsquo;s installed.
Configuring, starting, and stopping tunnels is handled by <code>wireguard-tools</code> and works exactly the same way with both versions.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span># pkg remove wireguard-kmod
</span></span><span style=display:flex><span><span style=color:#44475a>[...]
</span></span></span><span style=display:flex><span><span style=color:#44475a></span># pkg install wireguard-go
</span></span></code></pre></div><p>Now, running <code>service wireguard start</code> shows this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span># service wireguard start
</span></span><span style=display:flex><span><span style=color:#44475a>[#] ifconfig wg create name wg0
</span></span></span><span style=display:flex><span><span style=color:#44475a>[!] Missing WireGuard kernel support (ifconfig: SIOCIFCREATE2:
</span></span></span><span style=display:flex><span><span style=color:#44475a>Invalid argument). Falling back to slow userspace implementation.
</span></span></span><span style=display:flex><span><span style=color:#44475a>[#] wireguard-go wg0
</span></span></span><span style=display:flex><span><span style=color:#44475a>┌──────────────────────────────────────────────────────┐
</span></span></span><span style=display:flex><span><span style=color:#44475a>│                                                      │
</span></span></span><span style=display:flex><span><span style=color:#44475a>│   Running wireguard-go is not required because this  │
</span></span></span><span style=display:flex><span><span style=color:#44475a>│   kernel has first class support for WireGuard. For  │
</span></span></span><span style=display:flex><span><span style=color:#44475a>│   information on installing the kernel module,       │
</span></span></span><span style=display:flex><span><span style=color:#44475a>│   please visit:                                      │
</span></span></span><span style=display:flex><span><span style=color:#44475a>│         https://www.wireguard.com/install/           │
</span></span></span><span style=display:flex><span><span style=color:#44475a>│                                                      │
</span></span></span><span style=display:flex><span><span style=color:#44475a>└──────────────────────────────────────────────────────┘
</span></span></span><span style=display:flex><span><span style=color:#44475a>[...]
</span></span></span></code></pre></div><p>This is a bit of a mixed message.
With <code>wireguard-kmod</code>, I got a scary warning about it being experimental, but <code>wireguard-go</code> says it&rsquo;s OBE.
I want to use the in-kernel version for better performance, but I also want security and stability.
Let&rsquo;s see if the slow userspace implementation is really all that slow.</p><h3 id=freebsd-wireguard-shootout>FreeBSD Wireguard Shootout</h3><p>As an unscientific test, I set up a tunnel between my laptop with FreeBSD 13.1 and my Raspberry Pi both connected to the same switch over gigabit ethernet.
I ran <code>iperf3</code> to measure the throughput and <code>vmstat</code> to see CPU and memory usage.
Here are the network throughput results.</p><h4 id=baseline-no-tunnel>Baseline (No Tunnel)</h4><pre tabindex=0><code>[ ID] Interval           Transfer     Bitrate         Retr
[  5]   0.00-10.00  sec  1.09 GBytes   935 Mbits/sec    0   sender
[  5]   0.00-10.04  sec  1.09 GBytes   932 Mbits/sec        receiver
</code></pre><h4 id=wireguard-go><code>wireguard-go</code></h4><pre tabindex=0><code>[ ID] Interval           Transfer     Bitrate         Retr
[  5]   0.00-10.00  sec   661 MBytes   555 Mbits/sec  423   sender
[  5]   0.00-10.02  sec   661 MBytes   553 Mbits/sec        receiver
</code></pre><h4 id=wireguard-kmod><code>wireguard-kmod</code></h4><pre tabindex=0><code>[ ID] Interval           Transfer     Bitrate         Retr
[  5]   0.00-10.00  sec   787 MBytes   660 Mbits/sec  138   sender
[  5]   0.00-10.03  sec   786 MBytes   658 Mbits/sec        receiver
</code></pre><p>Compare the CPU usage stats from <code>vmstat</code>.
Each line is a half-second interval from the middle of the iperf test.</p><h4 id=baseline-no-tunnel-1>Baseline (No tunnel)</h4><pre tabindex=0><code>cpu
sy     cs    us sy id
97596  40992  1 12 87
96434  40968  3 11 87
98020  40760  4 12 84
</code></pre><h4 id=wireguard-go-1><code>wireguard-go</code></h4><pre tabindex=0><code>cpu
sy     cs    us sy id
210358 85010 17 16 67
221720 89424 21 15 63
215976 87518 12 20 68
</code></pre><h4 id=wireguard-kmod-1><code>wireguard-kmod</code></h4><pre tabindex=0><code>cpu
sy    cs    us sy id
14908 41894  1 27 72
13274 35634  2 27 71
14110 37270  1 29 70
</code></pre><p>The number of system calls (<code>sy</code>) is the reason to have wireguard in the kernel instead of userland.
The userland port made the most system calls to transfer the least data.
The idle number (<code>id</code>) also shows a difference big enough for a user to notice; the in-kernel version uses a bit less CPU time overall.</p><h3 id=on-linux>On Linux?</h3><p>Just for fun, I booted a live USB stick of Fedora Linux, which has WireGuard in the kernel, and tried the same test.</p><h4 id=baseline-no-tunnel-on-linux>Baseline (No Tunnel) on Linux</h4><pre tabindex=0><code>[ ID] Interval           Transfer     Bitrate         Retr
[  5]   0.00-10.00  sec  1.09 GBytes   936 Mbits/sec    0   sender
[  5]   0.00-10.00  sec  1.09 GBytes   934 Mbits/sec        receiver
</code></pre><h4 id=wireguard-on-linux><code>wireguard</code> on Linux</h4><pre tabindex=0><code>[ ID] Interval           Transfer     Bitrate         Retr
[  5]   0.00-10.00  sec   717 MBytes   601 Mbits/sec   78   sender
[  5]   0.00-10.00  sec   715 MBytes   600 Mbits/sec        receiver
</code></pre><h3 id=conclusions>Conclusions</h3><p>The goal of using WireGuard is to have a secure VPN connection with very little overhead.
In this test, <code>wireguard-go</code> on FreeBSD doesn&rsquo;t really deliver that.
If I were happy cutting network performance almost in half, I might as well use a different protocol.</p><p>On the other hand, <code>wireguard-kmod</code> clearly can perform better, even in casual use.
It performs about as well as the real competition, WireGuard on Linux.
Given that it&rsquo;s been over a year since the in-kernel WireGuard kerfuffle, I&rsquo;ll wager it&rsquo;s secure enough to use.</p></article></main><footer id=footer>Copyright © 2022 Benjamin Spiegel</footer></body></html>